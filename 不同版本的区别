http1.0:无连接,无状态,一次请求一个tcp连接
http1.1:持久连接,请求管道化(有一些缺陷) ,增加了host字段,缓存,断点续传
http2.0 : 二进制分帧(多路复用的实现基础), 多路复用,头部压


http1.0:

是一种无状态、无连接的应用层协议,每个请求都会新创建一个tcp连接,完成后关闭服务端不跟踪也不记录过去的请求(无状态),
但正因频繁创建连接,由于tcp的慢启动(为了不给网络造成拥堵,在首次进行tcp请求的时候,会限制服务端和客户端之间交互数据量的上限,
大概为14kb,之后以指数级增长),服务端接受请求,处理完,发送完响应之后就会将tcp连接关闭,这造成了很大的资源浪费,
而且http1.0在一个请求接收到响应之后才会接着发送下一个,这也造成了head of line blocking(队头阻塞),
现在的浏览器为了解决这个问题,采用了一个页面可以建立多个tcp连接的方式来进行


http1.1:

继承了http1.0的特点,同时改善了http的一些问题,首先是长连接,http1.1新增加了connecion字段,里面可以设置keey-Alive(保持连接)
或者close(关闭长连接),避免了每次请求都会新建连接,提高了网络的利用率
http1.1还增加了Host字段,用来明确表示浏览器要服务器上的哪一个WEB站点,
这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点,同时还支持了断点续传
http1.1的管道:可以发送很多请求到服务端,但是服务端必须要按顺序返回响应,
由此可以看出http1.1的管道只是把客户端的请求序列变成了服务端的响应序列,还是有问题,很多浏览器并不是很支持
http1.1还增加了缓存,断点续传


http2.0 : 

采用了二进制分帧(frame),在应用层和传输层之间增加了一个二进制分帧层,也就是把http1.x的header和body使用帧(frame)进行了封装
这里明确几个概念:
流(stream) : 已经建立上连接的双向字节流(也就是一个请求和其对应的响应) 
消息:与逻辑消息对应的完整的一系列数据帧 
帧(frame):http2.0进行通信的最小单位,每个帧都会包含一个头部,这个头部会包含当前帧所处的流
多路复用:   所有的HTTP2.0通信都在一个TCP连接上完成，
这个连接可以承载任意数量的双向数据流,每个数据流都以消息的方式进行发送,
这个发送可以使乱序的,然后在通过每个帧头部的流标识符进行组装,
同时每个数据流都可以设置优先级,
可见http2.0真正实现了并行发送数据,这个是给予二进制分帧来实现的
头部压缩:     就是和服务端约定头部的数据的编码,来将头部进行压缩后发送,这样就可以增加请求头的容量
